* function programming experimental lib

** why another fp lib

I like fp style and I haven't found a lib with these features:

- streamingly, I can handle infinite data source such as go channel or a socket reader
- lazy evaluation, well, huge list processing wouldn't make me oom
- generic, the interface{} type ocurrs in a map function sucks
- chain calls, functions should be compositional
- clean, I hope the core of the lib would be clean
- performance, good performance would be a bonus


And when I decide to build a new fp lib, the theory of lisp come to my mind immediately.

If I can bring cons,car,cdr into golang, that would be cool and attractive for me.

So I spend couple of days make this, and I hope you like it. Any feedback is welcome.

** source

Stream is created from a source, source is a slice, a channel, or even a reader.

e.g. create stream from slice

#+begin_src go
StreamOf([]int{1, 2, 3})
StreamOf([]string{"a", "b", "c"})
#+end_src

e.g. create stream from channel

#+begin_src go
ch := make(chan string, 1)
StreamOf(ch)
#+end_src

e.g. create stream from custom source

#+begin_src go
type Source interface {
	// source element type
	ElemType() reflect.Type
	// Next element
	Next() (reflect.Value, bool)
}

StreamOfSource(mySource)
// create a file source, read text line by line
file, _ := os.Open("example.txt")
defer file.Close()
source := NewLineSource(file)
StreamOfSource(source)
#+end_src


** high order functions

*** Map

#+begin_src go
slice := []string{"a", "b", "c"}
var out []string
StreamOf(slice).Map(strings.ToUpper).ToSlice(&out)
suite.ElementsMatch(out, []string{"A", "B", "C"})
#+end_src

*** FlatMap

#+begin_src go
// flatmap optional boolean values
slice := []string{"a", "b", "c"}
var out []string
StreamOf(slice).FlatMap(func(e string) (string, bool) {
	return strings.ToUpper(e), e == "b"
}).ToSlice(&out)
suite.ElementsMatch(out, []string{"B"})

// flatmap optional error values
slice := []string{"a", "b", "c"}
out = StreamOf(slice).FlatMap(func(e string) (string, error) {
	if e == "b" {
		return strings.ToUpper(e), errors.New("error")
	}
	return strings.ToUpper(e), nil
}).Result().Strings()
suite.ElementsMatch(out, []string{"A", "C"})

// flatmap sub collection
slice := []string{"abc", "de", "f"}
out := StreamOf(slice).FlatMap(func(s string) []byte {
	return []byte(s)
}).Result().Bytes()
suite.Equal("abcdef", string(out))
#+end_src

*** Filter

#+begin_src go
slice := []string{"a", "b", "c"}
out := StreamOf(slice).Filter(func(s string) bool {
	return s == "b"
}).Result().Strings()
suite.Equal([]string{"b"}, out)
#+end_src

*** Reject

#+begin_src go
slice := []string{"a", "b", "c"}
out := StreamOf(slice).Reject(func(s string) bool {
	return s == "b"
}).Result().Strings()
suite.Equal([]string{"a", "c"}, out)
#+end_src

*** Foreach

#+begin_src go
var out string
slice := []string{"abc", "de", "f"}
out1 := StreamOf(slice).Foreach(func(s string) {
	out += s
}).Result().Strings()
suite.Equal("abcdef", out)
suite.ElementsMatch(slice, out1)
#+end_src

*** Flatten

#+begin_src go
slice := []string{"abc", "de", "f"}
out := StreamOf(slice).Map(func(s string) []byte {
	return []byte(s)
}).Flatten().Result().Bytes()
suite.Equal("abcdef", string(out))
#+end_src

deep flatten

#+begin_src go
slice := [][]string{
	{"abc", "de", "f"},
	{"g", "hi"},
}
out := StreamOf(slice).Map(func(s []string) [][]byte {
	return StreamOf(s).Map(func(st string) []byte {
		return []byte(st)
	}).Result().Interface().([][]byte)
}).Flatten().Flatten().Result().Bytes()
suite.Equal("abcdefghi", string(out))
#+end_src

*** Partition/PartitionBy

#+begin_src go
source := []string{"a", "b", "c", "d"}

out := StreamOf(source).Partition(3).Result().StringsList()
suite.Equal([][]string{
	{"a", "b", "c"},
	{"d"},
}, out)

slice := []string{"a", "b", "c", "d", "e", "c", "c"}
out := StreamOf(slice).PartitionBy(func(s string) bool {
	return s == "c"
}, true).Result().StringsList()
suite.Equal([][]string{
	{"a", "b", "c"},
	{"d", "e", "c"},
	{"c"},
}, out)
#+end_src

*** Reduce

#+begin_src go
source := []string{"a", "b", "c", "d", "a", "c"}

out := StreamOf(source).Reduce(map[string]int{}, func(memo map[string]int, s string) map[string]int {
	memo[s] += 1
	return memo
}).Interface().(map[string]int)
suite.Equal(map[string]int{
	"a": 2,
	"b": 1,
	"c": 2,
	"d": 1,
}, out)
#+end_src

*** First

#+begin_src go
slice := []string{"abc", "de", "f"}
q := StreamOf(slice)
out := q.First()
suite.Equal("abc", out.String())
#+end_src

*** IsEmpty

#+begin_src go
slice := []string{"abc", "de", "f"}
q := StreamOf(slice)
suite.False(q.IsEmpty())
out := q.First()
suite.Equal("abc", out.String())
#+end_src

*** Take/TakeWhile

#+begin_src go
slice := []string{"abc", "de", "f"}
out := strings.Join(StreamOf(slice).Take(2).Result().Strings(), "")
suite.Equal("abcde", out)

slice := []string{"a", "b", "c"}
out := StreamOf(slice).TakeWhile(func(v string) bool {
	return v < "c"
}).Result().Strings()
suite.Equal([]string{"a", "b"}, out)
#+end_src

*** Skip/SkipWhile

#+begin_src go
slice := []string{"abc", "de", "f"}
out := strings.Join(StreamOf(slice).Skip(2).Result().Strings(), "")
suite.Equal("f", out)

slice := []string{"a", "b", "c"}
out := StreamOf(slice).SkipWhile(func(v string) bool {
	return v < "c"
}).Result().Strings()
suite.Equal([]string{"c"}, out)
#+end_src

*** Sort/SortBy

#+begin_src go
slice := []int{1, 3, 2}
out := StreamOf(slice).Sort().Result().Ints()
suite.Equal([]int{1, 2, 3}, out)

slice := []string{"abc", "de", "f"}
out := StreamOf(slice).SortBy(func(a, b string) bool {
	return len(a) < len(b)
}).Result().Strings()
suite.Equal([]string{"f", "de", "abc"}, out)
#+end_src

*** Uniq/UniqBy

#+begin_src go
slice := []int{1, 3, 2, 1, 2, 1, 3}
out := StreamOf(slice).Uniq().Result().Ints()
suite.ElementsMatch([]int{1, 2, 3}, out)

slice := []int{1, 3, 2, 1, 2, 1, 3}
out := StreamOf(slice).UniqBy(func(i int) bool {
	return i%2 == 0
}).Result().Ints()
suite.ElementsMatch([]int{1, 2}, out)
#+end_src

*** Size

#+begin_src go
out := StreamOf(slice).Size()
suite.Equal(2, out)
#+end_src

*** Contains

#+begin_src go
slice := []string{"abc", "de", "f"}
q := StreamOf(slice)
suite.True(q.Contains("de"))
#+end_src

*** GroupBy

#+begin_src go
slice1 := []string{"abc", "de", "f", "gh"}
q := StreamOf(slice1).Map(strings.ToUpper).GroupBy(func(s string) int {
	return len(s)
}).Result().(map[int][]string)
suite.Equal(map[int][]string{
	1: {"F"},
	2: {"DE", "GH"},
	3: {"ABC"},
}, q)
#+end_src

*** Append/Prepend

#+begin_src go
slice := []string{"abc", "de"}
out := StreamOf(slice).Append("A").Result().Strings()
suite.Equal([]string{"abc", "de", "A"}, out)

slice := []string{"abc", "de"}
out := StreamOf(slice).Prepend("A").Result().Strings()
suite.Equal([]string{"A", "abc", "de"}, out)
#+end_src

*** Union/Sub/Interact

#+begin_src go
slice1 := []string{"abc", "de", "f"}
slice2 := []string{"g", "hi"}
q1 := StreamOf(slice1).Map(strings.ToUpper)
q2 := StreamOf(slice2).Map(strings.ToUpper)
out := q2.Union(q1).Result().Strings()
suite.Equal([]string{"ABC", "DE", "F", "G", "HI"}, out)

slice1 := []int{1, 2, 3, 4}
slice2 := []int{2, 1}
out := StreamOf(slice1).Sub(StreamOf(slice2)).Result().Ints()
suite.Equal([]int{3, 4}, out)

slice1 := []int{1, 2, 3, 4}
slice2 := []int{2, 1}
out := StreamOf(slice1).Interact(StreamOf(slice2)).Result().Ints()
suite.ElementsMatch([]int{1, 2}, out)
#+end_src

*** Zip

#+begin_src go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6, 7}
out := StreamOf(slice1).Zip(StreamOf(slice2), func(i, j int) string {
	return strconv.FormatInt(int64(i+j), 10)
}).Result().Strings()
suite.ElementsMatch([]string{"5", "7", "9"}, out)
#+end_src

** Result

stream transform would not work unless Run/ToSlice/Result is invoked.

*** Run

use Run if you just want stream flows but do not care about the result

#+begin_src go
// the numbers would not print without Run
StreamOf(source).Foreach(func(i int) {
	fmt.Println(i)
}).Run()
#+end_src

*** ToSlice

#+begin_src go
slice := []string{"a", "b", "c"}
var out []string
StreamOf(slice).Map(strings.ToUpper).ToSlice(&out)
suite.ElementsMatch(out, []string{"A", "B", "C"})
#+end_src

*** Result

#+begin_src go
slice := []string{"a", "b", "c"}
q := StreamOf(slice).Map(strings.ToUpper)
out := q.Result().Strings()
suite.ElementsMatch(out, []string{"A", "B", "C"})
#+end_src
